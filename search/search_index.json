{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Apfel","text":"<p>\ud83c\udf4e <code>apfel</code> stands for A Personal Functional Extension Library, which provides a set of basic utilities designed for academic experiments.</p> <p>Apfel is the Deutsch word for apple.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Originally, the word 'functional' comes from the functional programming paradigm. However, Python is not inherently a functional programming language, and it is functional incomplete in many aspects.</p> <p>To fulfill my personal needs of writing elegant (and possibly efficient) code for  academic experiments evolving in an agile way, and to avoid pulling in less-maintained or less-documented third-party libraries, a personal toolkit is a better choice.</p> <p>It provides common helper functions, data types and sublanguages that aim to counter the missing features and design flaws of Python language itself. Heavy use of meta-programming, type hints and functional programming techniques are expected.</p>"},{"location":"#design-goals","title":"Design Goals","text":"<ul> <li> <p>Unpythonic.   Use best practices and API naming conventions from other languages,   especially Rust,   Haskell,   R,   and Julia to mitigate Python's limitations.</p> </li> <li> <p>Type safe.   Add expressive and sound type hints whenever possible.</p> </li> <li> <p>Low cost abstraction.   Try to use the most efficient underlying implementation.</p> </li> <li> <p>Minimal dependencies.   The library is kept (almost) self-contained, except those listed inside dependencies.</p> </li> </ul>"},{"location":"install/","title":"Installation","text":"<p>Warning</p> <p>This library is mainly personal and still in a very early stage.  We'll try to follow Semantic Versioning, but breaking changes should be expected.  If you are interested in using this library, please make sure to lock the version.</p>"},{"location":"install/#dependencies","title":"Dependencies","text":"<p>Currently, <code>apfel</code> requires Python 3.11 or later.</p> <p>The following dependencies are required:</p> <ul> <li><code>typing-extensions</code></li> </ul>"},{"location":"install/#installation_1","title":"Installation","text":"<p>This library is not published to PyPI. You should install it directly from the GitHub repository. Using <code>pyprojects.toml</code> and locking to a Git reference (e.g. a tag) is recommended.</p>"},{"location":"install/#in-pyprojectstoml","title":"In <code>pyprojects.toml</code>","text":"<pre><code>[package]\ndependencies = [\n    \"apfel @ git+https://github.com/Yixuan-Wang/apfel.git@v{VERSION}\"\n]\n</code></pre>"},{"location":"install/#in-pyprojectstoml-with-poetry","title":"In <code>pyprojects.toml</code> with Poetry","text":"<pre><code>[tool.poetry.dependencies]\napfel = { git = \"https://github.com/Yixuan-Wang/apfel.git\", tag = \"v{VERSION}\" }\n</code></pre>"},{"location":"install/#in-requirementstxt","title":"In <code>requirements.txt</code>","text":"<pre><code>apfel @ git+https://github.com/Yixuan-Wang/apfel.git@v{VERSION}\n</code></pre>"},{"location":"install/#direct-installation","title":"Direct Installation","text":"<pre><code>pip install git+https://github.com/Yixuan-Wang/apfel.git@v{VERSION}\n</code></pre>"},{"location":"core/function-object/","title":"Function Object","text":"<p>This module provides <code>FunctionObject</code>, a wrapper to extend functions with methods and operator overloads, and can be called and passed around just like normal Python functions, or further combined and mutated as the functions in Haskell. Conceptually, function objects are objects that implement the function call operator.</p>"},{"location":"core/function-object/#apfel.core.function_object--usage","title":"Usage","text":"<p><code>FunctionObject</code>s are particularly useful in interactive environments. Instead of wrapping a large expression in another level of parentheses, you can use <code>|</code> or <code>@</code> operators to apply the function on the following expression. If an expression guarantees to not overload the <code>&amp;</code> operator, you can also use <code>&amp;</code> to apply the function on the left-hand side, which is handy in REPLs.</p> <pre><code>f | although(we(are_not(using(lisp() or are_we()))))\ndo_not(want_to(see(these(parentheses())))) &amp; f\n</code></pre> <p>Sometimes writing <code>f(...)</code> as <code>f@(...)</code> or <code>f|(...)</code> is kind of redundant, but these usages can be purged easily with simple search and replace. These operators are carefully chosen, as they are relatively rare in Python code. This is especially useful when you wrap some debugging or logging code around a function call. For example, with the following usage with <code>icecream</code>, you can replace <code>ic @</code> with empty string to remove all debugging code, without worrying of breaking the <code>get_pic()</code> call:</p> <pre><code>from icecream import ic as _ic\n\nic = func(_ic)\nresult = ic @ (\n    get_pic(iris)\n        .filter(...)\n        .sort_values(...)\n        .apply(...)\n        .head(10)\n)\n</code></pre> <p><code>|</code> and <code>@</code> have different operator precedence, the <code>|</code> has almost the lowest precedence of all Python operators, while the <code>@</code> has almost the highest precedence. This allows you combine expressions more flexibly without worrying about parentheses.</p> <p><code>**</code> and <code>%</code> operators are also provided for function composition and partial function creation.</p> <p>Tip</p> <p>Do not use <code>FunctionObject</code>s in library or main code base. Only use them in scripts, notebooks or REPLs. Function objects come with runtime costs. Albeit negligible most of the time, the cost could accumulate on critical paths.</p> <p><code>FunctionObject</code>s also have less static typing support. Do not use them in type-checked code.</p> <p>Warning</p> <p>Wrapping callables with <code>FunctionObject</code> will lose fields and methods of the original callable. Be cautious especially when wrapping other callable objects.</p> <p>Warning</p> <p>For performance considerations, the majority of <code>apfel</code> APIs are not wrapped in <code>FunctionObject</code>s.</p>"},{"location":"core/function-object/#classes","title":"Classes","text":""},{"location":"core/function-object/#functionobject","title":"<code>FunctionObject</code>","text":""},{"location":"core/function-object/#operator-applicationor","title":"operator-application(or)","text":"<pre><code>def |[\n    T, R,\n    Self: Callable[[T], R],\n](\n    self,\n    rhs: T,\n) -&gt; R\n</code></pre> <p>Function application operator <code>|</code> for <code>FunctionObject</code>s.</p> <p><code>f | x</code> is equivalent to <code>f(x)</code>. This operator behaves the same as <code>@</code>, but with a different precedence.</p> <p>Example</p> <pre><code>@func\ndef f(x):\n    return x * 2\n\nf | 1 + 2\n# 6\n</code></pre>"},{"location":"core/function-object/#operator-applicationand","title":"operator-application(and)","text":"<p><pre><code>def &amp;[\n    T, R,\n    Self: Callable[[T], R],\n](\n    self,\n    lhs: T,\n) -&gt; R\n</code></pre> Reverse function application operator <code>&amp;</code> for <code>FunctionObject</code>s. This operator overloading targets the right-hand side.</p> <p><code>x &amp; f</code> is equivalent to <code>f(x)</code>, if <code>&amp;</code> operator (left, <code>__and__</code>) is not overloaded by <code>x</code>'s type.</p> <p>Warning</p> <p><code>np.array</code> and array-like types are common overloaders of <code>&amp;</code>, therefore this operator cannot be used with them.</p> <p>Example</p> <pre><code>@func\ndef f(x):\n    return x + 1\n\n1 + 2 &amp; f\n# 6\n</code></pre>"},{"location":"core/function-object/#operator-applicationat","title":"operator-application(at)","text":"<pre><code>def @[F: Callable](self, rhs: F) -&gt; ...\n</code></pre> <p>Function application operator <code>@</code> for <code>FunctionObject</code>s.</p> <p><code>f @ x</code> is equivalent to <code>f(x)</code>. This operator behaves the same as <code>|</code>, but with a different precedence.</p> <p>Example</p> <pre><code>@func\ndef f(x):\n    return x * 2\n\nf @ 1 + 2\n# 4\n</code></pre>"},{"location":"core/function-object/#operator-composition","title":"operator-composition","text":"<pre><code>def **[F: Callable](self, rhs: F) -&gt; FunctionObject\n</code></pre> <p>Functional composition operator <code>**</code> for <code>FunctionObject</code>s.</p> <p><code>f ** g</code> is mathematically similar to $f \\circ g$.</p> <p>Example</p> <pre><code>@func\ndef f(x):\n    return x + 1\n\n@func\ndef g(x):\n    return x * 2\n\nh = f ** g\nh(1)\n# 3\n</code></pre>"},{"location":"core/function-object/#operator-bind","title":"operator-bind","text":"<pre><code>def %(self, rhs: tuple | dict) -&gt; FunctionObject raise TypeError\n</code></pre> <p>Bind operator <code>%</code> for <code>FunctionObject</code>s to create partial functions.</p> <p><code>x % (a, b, c)</code> binds positional arguments. <code>x % { \"a\": 1, \"b\": 2 }</code> binds keyword arguments.</p> <p>Note</p> <p>Use <code>bind</code> method for all usage <code>functools.partial</code> supported.</p> <p>Example</p> <pre><code>@func\ndef f(a, b, c):\n    return a + b + c\n\ng = f % (1, 2)\ng(3)\n# 6\n</code></pre>"},{"location":"core/function-object/#bind","title":"<code>bind</code>","text":"<pre><code>def bind(self, *args, **kwargs) -&gt; FunctionObject\n</code></pre> <p>Bind extra arguments to a <code>FunctionObject</code>. The returned function will be wrapped in another <code>FuncObject</code>.</p>"},{"location":"core/function-object/#functions","title":"Functions","text":""},{"location":"core/function-object/#func","title":"<code>func</code>","text":"<pre><code>def func[F: Callable](f: F) -&gt; F\ndef func[*Fs](*fs: *Fs) -&gt; tuple[*Fs]\n</code></pre> <p>Turn callables into <code>FunctionObject</code> yet keeps their original type hints.</p> <p>Example</p> <pre><code>@func\ndef f(a: int) -&gt; int:\n    return f + 1\n\nf | 1\n# 2\n\nprint, display, str = func(print, display, str)\n</code></pre> <p>Note</p> <p>As a callable, <code>FunctionObject</code> has less static typing support. <code>@func</code> erases type hints of <code>FunctionObject</code> while keeping the runtime type. If you want to retain the type hints, directly use <code>FunctionObject</code>'s constructor, or use <code>reveal_func</code> on an object with runtime type <code>FunctionObject</code>.</p>"},{"location":"core/function-object/#reveal_func","title":"<code>reveal_func</code>","text":"<pre><code>def reveal_func(func: Any) -&gt; FunctionObject raise TypeError\n</code></pre> <p>Cast a <code>FunctionObject</code> to <code>FunctionObject</code> type.</p> <p>Exception</p> <p>This function performs runtime check and raises <code>TypeError</code> if the input is not a <code>FunctionObject</code>.</p>"}]}