{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Apfel","text":"<p>\ud83c\udf4e <code>apfel</code> stands for A Personal Functional Extension Library, which provides a set of basic utilities designed for academic experiments.</p> <p>Apfel is the Deutsch word for apple.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Originally, the word 'functional' comes from the functional programming paradigm. However, Python is not inherently a functional programming language, and it is functional incomplete in many aspects.</p> <p>To fulfill my personal needs of writing elegant (and possibly efficient) code for  academic experiments evolving in an agile way, and to avoid pulling in less-maintained or less-documented third-party libraries, a personal toolkit is a better choice.</p> <p>It provides common helper functions, data types and sublanguages that aim to counter the missing features and design flaws of Python language itself. Heavy use of meta-programming, type hints and functional programming techniques are expected.</p>"},{"location":"#design-goals","title":"Design Goals","text":"<ul> <li> <p>Unpythonic.   Use best practices and API naming conventions from other languages,   especially Rust,   Haskell,   R,   and Julia to mitigate Python's limitations.</p> </li> <li> <p>Type safe.   Add expressive and sound type hints whenever possible.</p> </li> <li> <p>Low cost abstraction.   Try to use the most efficient underlying implementation.</p> </li> <li> <p>Minimal dependencies.   The library is kept (almost) self-contained, except those listed inside dependencies.</p> </li> </ul>"},{"location":"install/","title":"Installation","text":"<p>Warning</p> <p>This library is mainly personal and still in a very early stage.  We'll try to follow Semantic Versioning, but breaking changes should be expected.  If you are interested in using this library, please make sure to lock the version.</p>"},{"location":"install/#dependencies","title":"Dependencies","text":"<p>Currently, <code>apfel</code> requires Python 3.11 or later.</p> <p>The following dependencies are required:</p> <ul> <li><code>typing-extensions</code></li> </ul>"},{"location":"install/#installation_1","title":"Installation","text":"<p>This library is not published to PyPI. You should install it directly from the GitHub repository. Using <code>pyprojects.toml</code> and locking to a Git reference (e.g. a tag) is recommended.</p>"},{"location":"install/#in-pyprojectstoml","title":"In <code>pyprojects.toml</code>","text":"<pre><code>[package]\ndependencies = [\n    \"apfel @ git+https://github.com/Yixuan-Wang/apfel.git@v{VERSION}\"\n]\n</code></pre>"},{"location":"install/#in-pyprojectstoml-with-poetry","title":"In <code>pyprojects.toml</code> with Poetry","text":"<pre><code>[tool.poetry.dependencies]\napfel = { git = \"https://github.com/Yixuan-Wang/apfel.git\", tag = \"v{VERSION}\" }\n</code></pre>"},{"location":"install/#in-requirementstxt","title":"In <code>requirements.txt</code>","text":"<pre><code>apfel @ git+https://github.com/Yixuan-Wang/apfel.git@v{VERSION}\n</code></pre>"},{"location":"install/#direct-installation","title":"Direct Installation","text":"<pre><code>pip install git+https://github.com/Yixuan-Wang/apfel.git@v{VERSION}\n</code></pre>"},{"location":"core/function-object/","title":"Function Object","text":"<p>This module provides <code>FunctionObject</code>, a wrapper to extend functions with methods and operator overloads, and can be called just like normal Python functions. Yet they support numerous additional operators for function calling.</p> <p>Conceptually, function objects are objects that implement the function call operator.</p>"},{"location":"core/function-object/#apfel.core.function_object--usage","title":"Usage","text":"<p>Tip</p> <p>Use <code>FunctionObject</code> in interactive environments.</p> <p><code>FunctionObject</code>s are particularly useful in interactive environments. Instead of wrapping a large expression in another level of parentheses, you can use application operators provided by <code>FunctionObject</code> to apply the function on the following expression.</p> <pre><code>f | although(we(are_not(using(lisp() or are_we()))))\ndo_not(want_to(see(these(parentheses())))) &amp; f\n</code></pre> <p>Writing <code>f(...)</code> as <code>f@(...)</code> seems redundant, but these <code>@</code> usages can be purged easily with simple search and replace. <code>FunctionObject</code>'s operators are carefully chosen, as they:</p> <ol> <li>are relatively rare in Python</li> <li>have different precedence and associativity</li> </ol> <p>This is especially useful when you wrap some debugging or logging code around a function call. For example, with the following usage with <code>icecream</code>, you can replace <code>ic @</code> with empty string to remove all debugging code, without worrying of breaking the <code>get_pic()</code> call:</p> <pre><code>from icecream import ic as _ic\n\nic = func(_ic)\nresult = ic @ (\n    get_pic(iris)\n        .filter(...)\n        .sort_values(...)\n        .apply(...)\n        .head(10)\n)\n</code></pre> <p><code>|</code> and <code>@</code> have different operator precedence, the <code>|</code> has almost the lowest precedence of all Python operators, while the <code>@</code> has almost the highest precedence. This allows you combine expressions more flexibly without worrying about parentheses.</p> <p><code>&amp;</code> operator can be used to apply the function to its left-hand side, if the left-hand side does not overload the <code>&amp;</code> operator. This is similar to <code>&amp;</code>, <code>|&gt;</code> or roughly <code>%&gt;%</code>.</p> <p><code>**</code> operator has the highest precedence of all, and it has a unique associtivity from right to left. It can be used in wrapping multiple calls together without parentheses, like <code>f(g(x))</code> can be written as <code>f ** g ** x</code>. It roughly simulates <code>$</code>.</p> <p><code>%</code> operator is used for calling multi-argument functions.</p> <p>Tip</p> <p>Do not use <code>FunctionObject</code>s in library or main code base. Only use them in scripts, notebooks or REPLs. Function objects come with runtime costs. Albeit negligible most of the time, the cost could accumulate on critical paths.</p> <p><code>FunctionObject</code>s also have less static typing support. Do not use them in type-checked code.</p> <p>Warning</p> <p>Wrapping callables with <code>FunctionObject</code> will lose fields and methods of the original callable. Be cautious especially when wrapping other callable objects.</p> <p>Warning</p> <p>For performance considerations, the majority of <code>apfel</code> APIs are not wrapped in <code>FunctionObject</code>s.</p>"},{"location":"core/function-object/#classes","title":"Classes","text":""},{"location":"core/function-object/#functionobject","title":"<code>FunctionObject</code>","text":""},{"location":"core/function-object/#operator-or","title":"|","text":"<pre><code>def |[T, R](self, rhs: T) -&gt; R\n</code></pre> <p>Function application operator <code>|</code> for <code>FunctionObject</code>s.</p> <p><code>f | x</code> is equivalent to <code>f(x)</code>. This operator behaves the same as <code>@</code>, but with a different precedence.</p> <p>Example</p> <pre><code>@func\ndef f(x):\n    return x * 2\n\nf | 1 + 2\n# 6\n</code></pre>"},{"location":"core/function-object/#operator-at","title":"@","text":"<pre><code>def @[T, R](self, rhs: T) -&gt; R\n</code></pre> <p>Function application operator <code>@</code> for <code>FunctionObject</code>s.</p> <p><code>f @ x</code> is equivalent to <code>f(x)</code>. This operator behaves the same as <code>|</code>, but with a different precedence.</p> <p>Example</p> <pre><code>@func\ndef f(x):\n    return x * 2\n\nf @ 1 + 2\n# 4\n</code></pre>"},{"location":"core/function-object/#operator-and","title":"&amp;","text":"<p><pre><code>def &amp;[T, R](self, lhs: T) -&gt; R\n</code></pre> Reverse function application operator <code>&amp;</code> for <code>FunctionObject</code>s. This operator overloading targets the right-hand side.</p> <p><code>x &amp; f</code> is equivalent to <code>f(x)</code>, if <code>&amp;</code> operator (left, <code>__and__</code>) is not overloaded by <code>x</code>'s type.</p> <p>Warning</p> <p><code>np.array</code> and array-like types are common overloaders of <code>&amp;</code>, therefore this operator cannot be used with them.</p> <p>Example</p> <pre><code>@func\ndef f(x):\n    return x + 1\n\n1 + 2 &amp; f\n# 6\n</code></pre>"},{"location":"core/function-object/#operator-pow","title":"**","text":"<pre><code>def **[T, R](self, rhs: T) -&gt; R\n</code></pre> <p>Function application operator <code>**</code> for <code>FunctionObject</code>s.</p> <p><code>f ** g ** x</code> is equivalent to <code>f(g(x))</code>. This operator has the highest precedence of all overloadable operators, and it binds from right to left. It intends to simulate <code>$</code> operator, except the precedence.</p> <p>Example</p> <pre><code>@func\ndef f(x):\n    return x + 1\n\n@func\ndef g(x):\n    return x * 2\n\nf ** g ** 1\n# 3\n</code></pre>"},{"location":"core/function-object/#operator-mod","title":"%","text":"<pre><code>def %[R](self, rhs) -&gt; R\n</code></pre> <p>Function application operator <code>%</code> for <code>FunctionObject</code>s of multi-argument functions.</p> <ul> <li>If the right hand side is a Sequence, spreads the sequence as positional arguments. For example, <code>x % (a, b, c)</code> is equivalent to <code>x(a, b, c)</code>.</li> <li>If the right hand side is a Mapping, spreads the mapping as keyword arguments. For example, <code>x % { \"a\": 1, \"b\": 2, \"c\": 3 }</code> is equivalent to <code>x(a=1, b=2, c=3)</code>.</li> <li>Specifically, you can use <code>...</code> as the map key to pass keyword arguments with keyword arguments at the same time, <code>x % { ...: (1, 2), \"c\": 3 }</code> is equivalent to <code>x(1, 2, c=3)</code>.</li> <li>Otherwise, it calls on the right-hand side. This catches the case where you forget the trailing comma in the right-hand side tuple.</li> </ul> <p>Example</p> <pre><code>@func\ndef f(a, b, c):\n    return a + b + c\n\nf % (1, 2, 3)                  # 6\nf % { \"a\": 1, \"b\": 2, \"c\": 3 } # 6\nf % { ...: (1, 2), \"c\": 3 }    # 6\n</code></pre> <p>Warning</p> <p>This operator does not support the case where <code>...</code> (the <code>Ellipsis</code>, not <code>\"...\"</code>) is used as a keyword argument. However, this case is relatively rare, as <code>...</code> cannot be declared as argument name.</p>"},{"location":"core/function-object/#functions","title":"Functions","text":""},{"location":"core/function-object/#func","title":"<code>func</code>","text":"<pre><code>def func[F: Callable](f: F) -&gt; F\ndef func[*Fs](*fs: *Fs) -&gt; tuple[*Fs]\n</code></pre> <p>Turn callables into <code>FunctionObject</code> yet keeps their original type hints.</p> <p>Example</p> <pre><code>@func\ndef f(a: int) -&gt; int:\n    return f + 1\n\nf | 1\n# 2\n\nprint, display, str = func(print, display, str)\n</code></pre> <p>Note</p> <p>As a callable, <code>FunctionObject</code> has less static typing support. <code>@func</code> erases type hints of <code>FunctionObject</code> while keeping the runtime type. If you want to retain the type hints, directly use <code>FunctionObject</code>'s constructor, or use <code>reveal_func</code> on an object with runtime type <code>FunctionObject</code>.</p>"},{"location":"core/function-object/#reveal_func","title":"<code>reveal_func</code>","text":"<pre><code>def reveal_func(func: Any) -&gt; FunctionObject raise TypeError\n</code></pre> <p>Cast a <code>FunctionObject</code> to <code>FunctionObject</code> type.</p> <p>Exception</p> <p>This function performs runtime check and raises <code>TypeError</code> if the input is not a <code>FunctionObject</code>.</p>"},{"location":"core/function/","title":"Common Functions","text":""},{"location":"core/function/#apfel.core.function.identity","title":"<code>identity(x)</code>","text":"<p>Returns the sole argument passed to it doing nothing.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>T</code> <p>Any object.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The same object passed to it.</p>"},{"location":"core/function/#apfel.core.function.todo","title":"<code>todo(message=None)</code>","text":"<p>Marks an unimplemented location that might be implemented in the future. See <code>todo!</code> for usage.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | None</code> <p>The extra message to be displayed.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always.</p>"},{"location":"core/function/#apfel.core.function.unimplemented","title":"<code>unimplemented(message=None)</code>","text":"<p>Marks an unimplemented location that might not be implemented in the future. See <code>unimplemented!</code> for usage.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | None</code> <p>The extra message to be displayed.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always.</p>"}]}