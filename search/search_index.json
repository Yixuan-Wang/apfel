{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Apfel","text":"<p>\ud83c\udf4e <code>apfel</code> stands for A Personal Functional Extension Library, which provides a set of basic utilities designed for academic experiments.</p> <p>Apfel is the Deutsch word for apple.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Originally, the word 'functional' comes from the functional programming paradigm. However, Python is not inherently a functional programming language, and it is functional incomplete in many aspects.</p> <p>To fulfill my personal needs of writing elegant (and possibly efficient) code for  academic experiments evolving in an agile way, and to avoid pulling in less-maintained or less-documented third-party libraries, a personal toolkit is a better choice.</p> <p>It provides common helper functions, data types and sublanguages that aim to counter the missing features and design flaws of Python language itself. Heavy use of meta-programming, type hints and functional programming techniques are expected.</p>"},{"location":"#design-goals","title":"Design Goals","text":"<ul> <li> <p>Unpythonic.   Use best practices and API naming conventions from other languages,   especially Rust,   Haskell,   R,   and Julia to mitigate Python's limitations.</p> </li> <li> <p>Type safe.   Add expressive and sound type hints whenever possible.</p> </li> <li> <p>Low cost abstraction.   Try to use the most efficient underlying implementation.</p> </li> <li> <p>Minimal dependencies.   The library is kept (almost) self-contained, except those listed inside dependencies.</p> </li> </ul>"},{"location":"install/","title":"Installation","text":"<p>Warning</p> <p>This library is mainly personal and still in a very early stage.  We'll try to follow Semantic Versioning, but breaking changes should be expected.  If you are interested in using this library, please make sure to lock the version.</p>"},{"location":"install/#dependencies","title":"Dependencies","text":"<p>Currently, <code>apfel</code> requires Python 3.11 or later.</p> <p>The following dependencies are required:</p> <ul> <li><code>typing-extensions</code></li> </ul>"},{"location":"install/#installation_1","title":"Installation","text":"<p>This library is not published to PyPI. You should install it directly from the GitHub repository. Using <code>pyprojects.toml</code> and locking to a Git reference (e.g. a tag) is recommended.</p>"},{"location":"install/#in-pyprojectstoml","title":"In <code>pyprojects.toml</code>","text":"<pre><code>[package]\ndependencies = [\n    \"apfel @ git+https://github.com/Yixuan-Wang/apfel.git@v{VERSION}\"\n]\n</code></pre>"},{"location":"install/#in-pyprojectstoml-with-poetry","title":"In <code>pyprojects.toml</code> with Poetry","text":"<pre><code>[tool.poetry.dependencies]\napfel = { git = \"https://github.com/Yixuan-Wang/apfel.git\", tag = \"v{VERSION}\" }\n</code></pre>"},{"location":"install/#in-requirementstxt","title":"In <code>requirements.txt</code>","text":"<pre><code>apfel @ git+https://github.com/Yixuan-Wang/apfel.git@v{VERSION}\n</code></pre>"},{"location":"install/#direct-installation","title":"Direct Installation","text":"<pre><code>pip install git+https://github.com/Yixuan-Wang/apfel.git@v{VERSION}\n</code></pre>"},{"location":"core/dispatch/","title":"Dispatch","text":"<p>Dynamic dispatch for Python.</p> <p>This address the lack of runtime-available, inheritance-free interfaces in Python. It partially resembles the <code>extension</code> and <code>trait</code>.</p>"},{"location":"core/dispatch/#apfel.core.dispatch--rationale","title":"Rationale","text":"<p>Why not <code>functools.singledispatch</code>? This API is added in Python 3.4, and it uses type hints to dispatch functions. However, as Python develops, type hints are disentangled from concrete types. Using type hints to dispatch functions can be error-prone. Besides, its method counterpart <code>functools.singledispatchmethod</code> dispatches methods based on the first non-first argument, which is very different from the single dispatch found in object-oriented programming.</p> <p>Why not <code>abc.ABC</code>? <code>abc.ABC</code> enables inheritance-free interfaces with the .add_impl<code>](https://docs.python.org/3/library/abc.html#abc.ABC.add_impl){ .ref .py } method, but it does not enable [</code>virtual`-like dispatch.</p>"},{"location":"core/dispatch/#apfel.core.dispatch--usage","title":"Usage","text":"<p>By default the utilities in <code>dispatch</code> module are for single dispatch. This means the dispatch is based on the concrete type of first argument of the function, or of the receiver in the case of methods.</p>"},{"location":"core/dispatch/#apfel.core.dispatch.ABCDispatchMeta","title":"<code>ABCDispatchMeta</code>","text":""},{"location":"core/dispatch/#apfel.core.dispatch.IABCDispatch","title":"<code>IABCDispatch</code>","text":"<p>A protocol for ABCs that supports dispatching regardless of dispatch flavor.</p>"},{"location":"core/dispatch/#apfel.core.dispatch.ABCDispatch","title":"<code>ABCDispatch</code>","text":"<p>An <code>ABC</code> that enables single dispatch for its abstract methods. This behaves similarly to <code>abc.ABC</code> but with the added feature of single dispatch. Stick to built-in <code>abc.abstractmethod</code> to define abstract methods.</p> <p>See the usage section for more information.</p> <p>Example</p> <pre><code>from abc import abstractmethod\nfrom apfel.core.dispatch import ABCDispatch\n\nclass A(ABCDispatch):\n    @abstractmethod\n    def hi(self):\n        print(self)\n\n    @classmethod\n    @abstractmethod\n    def hey(cls):\n        print(cls)\n\na: A = some_instance()\nA.hi(a)\n</code></pre>"},{"location":"core/dispatch/#apfel.core.dispatch.IDispatchRegistry","title":"<code>IDispatchRegistry</code>","text":"<p>A protocol for dispatch registry. A dispatch registry is a collection of implementations of a   polymorphic function or method.</p>"},{"location":"core/dispatch/#apfel.core.dispatch.IDispatchRegistry.add_impl","title":"<code>add_impl(func, *args, **kwargs)</code>","text":"<p><pre><code>def add_impl(self, func: Callable[P, R], *args: K.args, **kwargs: K.kwargs)\n</code></pre> Add a new implementation to the registry.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The implementation to be added.</p> required <code>...</code> <code>K</code> <p>The implementor of the implementation added.</p> required"},{"location":"core/dispatch/#apfel.core.dispatch.IDispatchRegistry.decide_impl","title":"<code>decide_impl(*args, **kwargs)</code>","text":"<p><pre><code>def decide_impl(self, *args: P.args, **kwargs: R.args) -&gt; Callable[P, R]\n</code></pre> Decide which implementation should be used based on the arguments.</p> <p>This method should not call the implementation directly, but return a reference to it.</p> <p>Returns:</p> Type Description <code>Callable</code> <p>The implementation to be used.</p>"},{"location":"core/dispatch/#apfel.core.dispatch.IDispatchRegistry.get_impl","title":"<code>get_impl(*args, **kwargs)</code>","text":"<p><pre><code>def get_impl(self, *args: K.args, **kwargs: K.kwargs) -&gt; Callable raise KeyError\n</code></pre> Get an implementation from the registry.</p> <p>Parameters:</p> Name Type Description Default <code>...</code> <code>K</code> <p>The implementor of the implementation.</p> required <p>Returns:</p> Type Description <code>Callable[P, R]</code> <p>The implementation.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no such implementation is found.</p>"},{"location":"core/dispatch/#apfel.core.dispatch.IDispatchRegistry.make_dispatch_func","title":"<code>make_dispatch_func(func)</code>","text":"<p><pre><code>def make_dispatch_func(self, func: Callable[P, R]) -&gt; Callable[P, R]\n</code></pre> Make a function or callable that uses this registry to perform dynamic dispatch.</p> Notes <p>This method should typically be implemented as a higher-order function, which returns a new function that wraps the original function with the dispatch logic. An example implementation of this method: <pre><code>def make_dispatch_func(self, func):\n    def dyn(*args, **kwargs):\n        return self.decide_impl(*args, **kwargs)(*args, **kwargs)\n\n    functools.update_wrapper(dyn, func)\n    return dyn\n</code></pre></p>"},{"location":"core/function-object/","title":"Function Object","text":"<p>This module provides <code>FunctionObject</code>, a wrapper to extend functions with operator overloads for function calling.</p> <p>Conceptually, function objects are objects that implement the function call operator.</p>"},{"location":"core/function-object/#apfel.core.function_object--usage","title":"Usage","text":"TL;DR <p>Use and only use function objects in interactive environments.</p> <p><code>FunctionObject</code>s are particularly useful in interactive environments. Instead of wrapping a large expression in another level of parentheses, you can use application operators provided by <code>FunctionObject</code> to apply the function on the following expression. Use the <code>fob</code> function to turn a function or a sequence of functions into <code>FunctionObject</code>s.</p> <p>For example, <code>f(..)</code> is equivalent to <code>f | (...)</code> or <code>f @ (...)</code>. Writing <code>f(...)</code> as <code>f@(...)</code> seems redundant, but these <code>@</code> usages can be purged easily with simple search and replace. <code>FunctionObject</code>'s operators are carefully chosen, as they:</p> <ol> <li>are relatively rare in Python</li> <li>have different precedence and associativity</li> </ol> <p>This is especially useful when you wrap some debugging or logging code around a function call. For example, with the following usage with <code>icecream</code>, you can replace <code>ic @</code> with empty string to remove all debugging code, without worrying of breaking the <code>get_pic()</code> call:</p> <pre><code>from icecream import ic as _ic\n\nic = fob(_ic)\nresult = ic @ (\n    get_pic(iris)\n        .filter(...)\n        .sort_values(...)\n        .apply(...)\n        .head(10)\n)\n</code></pre> <p><code>|</code> and <code>@</code> have different operator precedence, the <code>|</code> has almost the lowest precedence of all Python operators, while the <code>@</code> has almost the highest precedence. This allows you combine expressions more flexibly without worrying about parentheses.</p> <p><code>&amp;</code> operator can be used to apply the function to its left-hand side, if the left-hand side does not overload the <code>&amp;</code> operator. This is similar to <code>&amp;</code>, <code>|&gt;</code> or roughly <code>%&gt;%</code>. With <code>&amp;</code> you can write your code naturally from left to right.</p> <pre><code>from icecream import ic as _ic\nic = fob(_ic)\n\nresult = (\n    get_pic(iris)\n        .filter(...)\n        # ...\n) &amp; ic\n</code></pre> <p><code>**</code> operator has the highest precedence of all, and it has a unique associtivity from right to left. It can be used in wrapping multiple calls together without parentheses, like <code>f(g(x))</code> can be written as <code>f ** g ** x</code>. It roughly simulates <code>$</code>.</p> <p><code>%</code> operator is used for calling multi-argument functions.</p> Tip <p>Function objects come with runtime costs. Although negligible most of the time, the cost could accumulate on critical paths.</p> <p><code>FunctionObject</code>s also have less static typing support. Do not use them in type-checked code.</p> Warning <p>Wrapping callables other than functions with <code>FunctionObject</code> may lose attributes  and methods of the original callable.</p> Warning <p>For performance considerations, <code>apfel</code> APIs are not wrapped in <code>FunctionObject</code>s.</p>"},{"location":"core/function-object/#apfel.core.function_object.FunctionObject","title":"<code>FunctionObject</code>","text":""},{"location":"core/function-object/#apfel.core.function_object.FunctionObject.__matmul__","title":"<code>__matmul__(rhs)</code>","text":"<pre><code>def @[T, R](self, rhs: T) -&gt; R\n</code></pre> <p>Function application operator <code>@</code> for <code>FunctionObject</code>s.</p> <p><code>f @ x</code> is equivalent to <code>f(x)</code>. This operator behaves the same as <code>|</code>, but with a different precedence.</p> Example <pre><code>@fob\ndef f(x):\n    return x * 2\n\nf @ 1 + 2\n# 4\n</code></pre>"},{"location":"core/function-object/#apfel.core.function_object.FunctionObject.__mod__","title":"<code>__mod__(rhs)</code>","text":"<pre><code>def %[R](self, rhs) -&gt; R\n</code></pre> <p>Function application operator <code>%</code> for <code>FunctionObject</code>s of multi-argument functions.</p> <ul> <li>If the right hand side is a Sequence, spreads the sequence as positional arguments. For example, <code>x % (a, b, c)</code> is equivalent to <code>x(a, b, c)</code>.</li> <li>If the right hand side is a Mapping, spreads the mapping as keyword arguments. For example, <code>x % { \"a\": 1, \"b\": 2, \"c\": 3 }</code> is equivalent to <code>x(a=1, b=2, c=3)</code>.</li> <li>Specifically, you can use <code>...</code> as the map key to pass keyword arguments with keyword arguments at the same time, <code>x % { ...: (1, 2), \"c\": 3 }</code> is equivalent to <code>x(1, 2, c=3)</code>.</li> <li>Otherwise, it calls on the right-hand side. This catches the case where you forget the trailing comma in the right-hand side tuple.</li> </ul> Example <pre><code>@fob\ndef f(a, b, c):\n    return a + b + c\n\nf % (1, 2, 3)                  # 6\nf % { \"a\": 1, \"b\": 2, \"c\": 3 } # 6\nf % { ...: (1, 2), \"c\": 3 }    # 6\n</code></pre> Warning <p>This operator does not support the case where <code>...</code> (the <code>Ellipsis</code>, not <code>\"...\"</code>) is used as a keyword argument. However, this case is relatively rare, as <code>...</code> cannot be declared as argument name.</p>"},{"location":"core/function-object/#apfel.core.function_object.FunctionObject.__or__","title":"<code>__or__(rhs)</code>","text":"<pre><code>def |[T, R](self, rhs: T) -&gt; R\n</code></pre> <p>Function application operator <code>|</code> for <code>FunctionObject</code>s.</p> <p><code>f | x</code> is equivalent to <code>f(x)</code>. This operator behaves the same as <code>@</code>, but with a different precedence.</p> Example <pre><code>@fob\ndef f(x):\n    return x * 2\n\nf | 1 + 2\n# 6\n</code></pre>"},{"location":"core/function-object/#apfel.core.function_object.FunctionObject.__pow__","title":"<code>__pow__(rhs)</code>","text":"<pre><code>def **[T, R](self, rhs: T) -&gt; R\n</code></pre> <p>Function application operator <code>**</code> for <code>FunctionObject</code>s.</p> <p><code>f ** g ** x</code> is equivalent to <code>f(g(x))</code>. This operator has the highest precedence of all overloadable operators, and it binds from right to left. It intends to simulate <code>$</code> operator, except the precedence.</p> Example <pre><code>@fob\ndef f(x):\n    return x + 1\n\n@fob\ndef g(x):\n    return x * 2\n\nf ** g ** 1\n# 3\n</code></pre>"},{"location":"core/function-object/#apfel.core.function_object.FunctionObject.__rand__","title":"<code>__rand__(lhs)</code>","text":"<p><pre><code>def &amp;[T, R](self, lhs: T) -&gt; R\n</code></pre> Reverse function application operator <code>&amp;</code> for <code>FunctionObject</code>s. This operator overloading targets the right-hand side.</p> <p><code>x &amp; f</code> is equivalent to <code>f(x)</code>, if <code>&amp;</code> operator (left, <code>__and__</code>) is not overloaded by <code>x</code>'s type.</p> Warning <p><code>np.array</code> and array-like types are common overloaders of <code>&amp;</code>, therefore this operator cannot be used with them.</p> Example <pre><code>@fob\ndef f(x):\n    return x + 1\n\n1 + 2 &amp; f\n# 6\n</code></pre>"},{"location":"core/function-object/#apfel.core.function_object.fob","title":"<code>fob(f, *fs)</code>","text":"<pre><code>def fob[F: Callable](f: F) -&gt; F\ndef fob[*Fs](*fs: *Fs) -&gt; tuple[*Fs]\n</code></pre> <p>Turn callables into <code>FunctionObject</code> yet keeps their original type hints.</p> Example <pre><code>@fob\ndef f(a: int) -&gt; int:\n    return f + 1\n\nf | 1\n# 2\n\nprint, display, str = fob(print, display, str)\n</code></pre> Note <p>As a callable, <code>FunctionObject</code> has less static typing support. <code>@fob</code> erases type hints of <code>FunctionObject</code> while keeping the runtime type. If you want to retain the type hints, directly use <code>FunctionObject</code>'s constructor, or use <code>reveal_fob</code> on an object with runtime type <code>FunctionObject</code>.</p>"},{"location":"core/function-object/#apfel.core.function_object.reveal_fob","title":"<code>reveal_fob(f)</code>","text":"<pre><code>def reveal_fob(func: Any) -&gt; FunctionObject raise TypeError\n</code></pre> <p>Cast a <code>FunctionObject</code> to <code>FunctionObject</code> type.</p> Exception <p>This function performs runtime check and raises <code>TypeError</code> if the input is not a <code>FunctionObject</code>.</p>"},{"location":"core/function/","title":"Common Functions","text":""},{"location":"core/function/#apfel.core.function.identity","title":"<code>identity(x)</code>","text":"<p>Returns the sole argument passed to it doing nothing.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>T</code> <p>Any object.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The same object passed to it.</p>"},{"location":"core/function/#apfel.core.function.todo","title":"<code>todo(message=None)</code>","text":"<p>Marks an unimplemented location that might be implemented in the future. See <code>todo!</code> for usage.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | None</code> <p>The extra message to be displayed.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always.</p>"},{"location":"core/function/#apfel.core.function.unimplemented","title":"<code>unimplemented(message=None)</code>","text":"<p>Marks an unimplemented location that might not be implemented in the future. See <code>unimplemented!</code> for usage.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | None</code> <p>The extra message to be displayed.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always.</p>"},{"location":"core/monad/","title":"Monad","text":""},{"location":"core/monad/#apfel.core.monad.Functor","title":"<code>Functor</code>","text":"<pre><code>class Functor[T](ABC):\n    map\n    * = ...\n</code></pre> <p>A functor is a type that can apply a function to its inner value(s) without changing its structure.</p> <p>To implement a <code>Functor</code>, you need to implement at least the <code>map</code> method.</p> <p>See Functor for more information.</p> <p>Info</p> <p>A <code>Functor</code> implementation must adhere to the Functor Laws:</p> <ol> <li>Identity: <code>f.map(lambda x: x) == f</code></li> <li>Composition: <code>f.map(lambda x: h(g(x))) == f.map(g).map(h)</code></li> </ol>"},{"location":"core/monad/#apfel.core.monad.Functor.__xor__","title":"<code>__xor__(f)</code>","text":"<pre><code>def ^[F: Callable[[T], R], R](self, f: F)-&gt; Self[R]\n</code></pre> <p>Map operator <code>^</code>, purely syntactic sugar for <code>map</code>.</p>"},{"location":"core/monad/#apfel.core.monad.Functor.map","title":"<code>map(f)</code>  <code>abstractmethod</code>","text":"<pre><code>def map[F, R](self, f: F) -&gt; Self[R]\n    where F: Callable[[T], R]\n</code></pre> <p>Apply a function to the inner value(s) of the functor, returning a new  instance of the functor. This corresponds to the <code>fmap</code> in Haskell.</p> <p>Built-in <code>map</code> function returns an iterator, not a new instance of the functor.</p> Example <pre><code>add = lambda x: x + 1\nFunctor.map([1, 2, 3], add) # [2, 3, 4]\nmap([1, 2, 3], add)         # &lt;map object at ...&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[T], R]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Functor[R]</code> <p>A new instance of the functor with transformed inner value(s).</p>"},{"location":"core/monad/#apfel.core.monad.Applicative","title":"<code>Applicative</code>","text":"<pre><code>class Applicative[T](Functor):\n    pure\n    apply\n    @ = ...\n</code></pre> <p>An applicative functor is a functor extended with the ability to apply an effectful function to its inner value(s).</p> <p>To implement an <code>Applicative</code>, you need to implement at least the <code>pure</code> and <code>apply</code> methods.</p> <p>See Applicative for more information.</p>"},{"location":"core/monad/#apfel.core.monad.Applicative.__matmul__","title":"<code>__matmul__(x)</code>  <code>classmethod</code>","text":"<pre><code>def @(self, x: T) -&gt; Self[T]\n</code></pre> <p>Applicative operator <code>@</code>, purely syntactic sugar for <code>pure</code>.</p>"},{"location":"core/monad/#apfel.core.monad.Applicative.apply","title":"<code>apply(f)</code>  <code>abstractmethod</code>","text":"<pre><code>def apply[F, R](self, f: F) -&gt; Self[R]\n    where F: Self[Callable[[T], R]]\n</code></pre> <p>Applies a function wrapped inside the applicative structure to the inner value(s) of this applicative.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Applicative[Callable[[T], R]]</code> <p>The applicative that contains the function to apply.</p> required <p>Returns:</p> Type Description <code>Applicative[R]</code> <p>A new instance of the applicative with the transformed inner value(s).</p>"},{"location":"core/monad/#apfel.core.monad.Applicative.pure","title":"<code>pure(x)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>def pure(cls, x: T) -&gt; Self[T]\n</code></pre> <p>Wrap a value into the applicative structure.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>T</code> <p>The value to wrap.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the applicative with the value wrapped.</p>"},{"location":"core/monad/#apfel.core.monad.Monad","title":"<code>Monad</code>","text":"<pre><code>class Monad[T](Applicative):\n    bind\n    (Applicative.pure)\n</code></pre> <p>A monad is an applicative functor extended with the ability to reuse results of previous computations and chain effectful computations together.</p> <p>To implement a <code>Monad</code>, you need to implement at least the <code>bind</code> method, and the <code>pure</code> method from <code>Applicative</code>.</p> <p>See Monad for more information.</p> Notes <p><code>return</code> is a reserved keyword in Python, and Haskell <code>return</code> is a historical mistake that is now pointing to <code>pure</code>.</p>"},{"location":"core/monad/#apfel.core.monad.Monad.bind","title":"<code>bind(f)</code>  <code>abstractmethod</code>","text":"<pre><code>def bind[F, R](self, f: F) -&gt; Self[R]\n    where F: Callable[[T], Self[R]]\n</code></pre> <p>Chain a new monadic computation to the current one.</p> <p>The argument <code>f</code> maps a pure value of the monad's inner type to the monadic value. <code>bind</code> chains this computation to the one it represents. If its computation fails, the following computations will not be executed.</p> <p>The function <code>f</code> is called a Kleisli arrow. This <code>bind</code> operation has other names in different programming languages. For example, in <code>Option</code> monad, it is called <code>and_then</code>.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[T], Monad[R]]</code> <p>The function that returns a new monadic computation.</p> required <p>Returns:</p> Type Description <code>Monad[R]</code> <p>A new instance of the monad with the result of the chained computation.</p>"}]}