{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Apfel","text":"<p>\ud83c\udf4e <code>apfel</code> stands for A Personal Functional Extension Library, which provides a set of basic utilities designed for academic experiments.</p> <p>Trivia</p> <p>Apfel is the Deutsch word for apple.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Originally, the word 'functional' comes from the functional programming paradigm. However, Python is not inherently a functional programming language, and it is functional incomplete in many aspects.</p> <p>To fulfill my personal needs of writing elegant (and possibly efficient) code for  academic experiments evolving in an agile way, and to avoid pulling in less-maintained or less-documented third-party libraries, a personal toolkit is a better choice.</p> <p>It provides common helper functions, data types and sublanguages that aim to counter the missing features and design flaws of Python language itself. Heavy use of meta-programming, type hints and functional programming techniques are expected.</p>"},{"location":"#design-goals","title":"Design Goals","text":"<ul> <li> <p>Unpythonic.   Use best practices and API naming conventions from other languages,   especially Rust,   Haskell,   R,   and Julia to mitigate Python's limitations.   Go is also a good reference for simplicity and readability comparable to Python.</p> </li> <li> <p>Type safe.   Add expressive and sound type hints whenever possible.</p> </li> <li> <p>Low cost abstraction.   Try to use the most efficient underlying implementation.</p> </li> <li> <p>Minimal dependencies.   The library is kept (almost) self-contained, except those listed inside dependencies.</p> </li> </ul>"},{"location":"#acknowledgement","title":"Acknowledgement","text":"<p>The apple logo used in the document is from the Noto Color Emoji font by Google.</p>"},{"location":"install/","title":"Installation","text":"<p>Warning:     This library is mainly personal and still in a very early stage.      We'll try to follow Semantic Versioning, but breaking changes should be expected.      If you are interested in using this library, please make sure to lock the version.</p>"},{"location":"install/#dependencies","title":"Dependencies","text":"<p>Currently, <code>apfel</code> requires Python 3.10 or later. Development environment require at least Python 3.11.</p> <p><code>apfel</code> depends on the following packages:</p> <ul> <li><code>typing-extensions</code></li> </ul>"},{"location":"install/#installation_1","title":"Installation","text":"<p>This library is not published to PyPI. You should install it directly from the GitHub repository. Using <code>pyproject.toml</code> and locking to a Git reference (e.g. a tag) is recommended.</p>"},{"location":"install/#pip","title":"<code>pip</code>","text":"<p>This is not recommended as you cannot lock the version with <code>pip</code>.</p> <pre><code>pip install git+https://github.com/Yixuan-Wang/apfel.git@v{VERSION}\n</code></pre>"},{"location":"install/#uv","title":"<code>uv</code>","text":"<pre><code>uv add git+https://github.com/Yixuan-Wang/apfel.git --tag \"v{VERSION}\"\n\n# or\n\nuv add git+https://github.com/Yixuan-Wang/apfel.git --ref \"{COMMIT_SHA}\"\n</code></pre>"},{"location":"install/#pdm","title":"<code>pdm</code>","text":"<pre><code>pdm add \"apfel @ git+https://github.com/Yixuan-Wang/apfel.git@v{VERSION}\"\n</code></pre>"},{"location":"install/#in-pyprojecttoml","title":"In <code>pyproject.toml</code>","text":"<pre><code>[package]\ndependencies = [\n    \"apfel @ git+https://github.com/Yixuan-Wang/apfel.git@v{VERSION}\"\n]\n</code></pre>"},{"location":"install/#in-pyprojecttoml-with-poetry","title":"In <code>pyproject.toml</code> with Poetry","text":"<pre><code>[tool.poetry.dependencies]\napfel = { git = \"https://github.com/Yixuan-Wang/apfel.git\", tag = \"v{VERSION}\" }\n</code></pre>"},{"location":"install/#in-requirementstxt","title":"In <code>requirements.txt</code>","text":"<pre><code>apfel @ git+https://github.com/Yixuan-Wang/apfel.git@v{VERSION}\n</code></pre>"},{"location":"container/maybe/","title":"Maybe","text":"<p>A container that optionally holds a value.</p> <p>See <code>Option</code> and <code>Maybe</code>.</p> <p>A <code>Maybe</code> has two possible states, <code>Just</code> or <code>Nothing</code>. <code>Just</code> means a value is present, and <code>Nothing</code> means the value is absent. The reason that we don't use <code>Some</code>-<code>None</code> or <code>Nil</code> nomencalture is to avoid confusion with the built-in <code>None</code>.</p> <p>This module also provides a <code>some</code> constructor, which converts an <code>Optional[T]</code> value to a <code>Maybe[T]</code> value.</p>"},{"location":"container/maybe/#apfel.container.maybe--rationale","title":"Rationale","text":"<p>Python has a built-in <code>None</code> object that represents the absence of a value, and a corresponding type hint <code>Optional[T]</code>. However, an <code>Optional[T]</code> is semantically different from a <code>Maybe[T]</code> object. An <code>Optional[T]</code> is a union of <code>T</code> and <code>None</code>, not a single object. To use a union, you must explicitly check its type before every use.</p> <pre><code># Usage 1\nif optional is None:\n    ...\nelse:\n    do_something(optional)\n\n# Usage 2\ndo_something(optional) if optional is not None else ...\n\n# Usage 3\noptional is not None and do_something(optional)\n</code></pre> <p>On the other hand, a <code>Maybe[T]</code> object represents the absence of a value as a state. Operations defined on <code>Maybe[T]</code> objects behave differently depending on the state of the object, but they are always available regardless of the state.</p> <pre><code>j: Maybe[int] = just(42)\nj.map(do_something) #(1)!\n\nn: Maybe[int] = nothing()\nn.map(do_something) #(2)!\n</code></pre> <ol> <li><code>do_something</code> is called because <code>j</code> is <code>Just</code>.</li> <li><code>do_something</code> is not called because <code>n</code> is <code>Nothing</code>.</li> </ol> <p>Warning</p> <p>Notice that <code>None</code> is not equal to <code>Nothing</code>. Use <code>Maybe.is_nothing()</code> to check if a <code>Maybe</code> object is <code>Nothing</code>.</p> <pre><code>nothing = Maybe[int].Nothing()\n\nassert nothing.is_nothing()\nassert nothing is not None\nassert nothing != None\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe--implementation","title":"Implementation","text":"<p><code>Maybe</code> implements the following interfaces:</p> Interface Methods <code>Functor</code> <code>map</code> <code>Applicative</code> <code>pure</code>, <code>apply</code> <code>Monad</code> <code>bind</code>(<code>and_then</code>) <p>The <code>Maybe</code> class is a generic class that holds a value of type <code>T</code> inside <code>_val</code> field. A boolean flag <code>_has_value</code> is used to indicate whether the value is present or absent. If <code>_has_value</code> is <code>False</code>, reading from <code>_val</code> is an undefined behavior.</p> <p><code>Maybe</code> and its methods do not support inherit-based subclassing.</p> <p><code>Maybe</code>'s APIs are based on the Rust <code>Option</code>, and the comparison table is provided below.</p> Reference <code>Option</code> Counterpart <code>and</code> <code>and_</code> <code>and_then</code> <code>as_deref</code> <code>as_deref_mut</code> <code>as_mut</code> <code>as_mut_slice</code> <code>as_pin_mut</code> <code>as_pin_ref</code> <code>as_ref</code> <code>as_slice</code> <code>cloned</code> <code>copied</code> <code>expect</code> <code>filter</code> <code>flatten</code> <code>get_or_insert</code> <code>get_or_insert_default</code> <code>get_or_insert_with</code> <code>insert</code> <code>inspect</code> <code>tap</code> <code>is_none</code> <code>is_nothing</code> <code>is_some</code> <code>is_just</code> <code>is_some_and</code> <code>is_just_and</code> <code>iter</code> <code>iter_mut</code> <code>map</code> <code>map_or</code> <code>map_or_else</code> <code>ok_or</code> <code>ok_or_else</code> <code>or</code> <code>or_</code> <code>or_else</code> <code>replace</code> <code>take</code> <code>take_if</code> <code>transpose</code> <code>unwrap</code> <code>unwrap_or</code> <code>unwrap_or_default</code> <code>unwrap_or_else</code> <code>unwrap_unchecked</code> <code>unzip</code> <code>xor</code> <code>zip</code> <code>zip_with</code>"},{"location":"container/maybe/#apfel.container.maybe.just","title":"<code>just</code>","text":"<p>Constructs a <code>Just</code> value.</p> <pre><code>j: Maybe[int] = just(42)\nj = just[int](42)\n\nassert j.is_just()\nassert j.unwrap() == 42\n</code></pre> <p>Warning</p> <p>Calling <code>just(None)</code> will return a <code>Just(None)</code> value, not a <code>Nothing</code> value. If you want to map <code>None</code> to <code>Nothing</code>, use <code>some</code> instead.</p>"},{"location":"container/maybe/#apfel.container.maybe.nothing","title":"<code>nothing</code>","text":"<p>Constructs a <code>Nothing</code> value. Notice that this is not a literal.</p> <pre><code>n: Maybe[int] = nothing()\nn = nothing[int]()\n\nassert n.is_nothing()\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.some","title":"<code>some</code>","text":"<p>Converts an <code>Optional[T]</code> to a <code>Maybe[T]</code> value.</p> <pre><code>something: Maybe[int] = some(42)\nassert something.is_just()\nassert something.unwrap() == 42\n\nsomething = some[int](None)\nassert something.is_nothing()\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe","title":"<code>Maybe</code>","text":"<p>A container that optionally holds a value. See module-level documentation for more information.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.__and__","title":"<code>__and__ = and_</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Alias of <code>and_</code>.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.__bool__","title":"<code>__bool__()</code>","text":"<p>Equivalent to <code>is_just</code>.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.__eq__","title":"<code>__eq__(other)</code>","text":"<p>If both values are <code>Just</code>, compare the inner values. Otherwise, return <code>True</code> if both are <code>Nothing</code>.</p> <p>Warning</p> <p>Notice that <code>None</code> is not equal to <code>Nothing</code>.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.__len__","title":"<code>__len__()</code>","text":"<p>Return 1 if the value is <code>Just</code>, otherwise 0.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.__or__","title":"<code>__or__ = or_</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Alias of <code>or_</code>.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.and_","title":"<code>and_(other)</code>","text":"<p>If the value is <code>Just</code>, return a shallow copy of the other <code>Maybe</code>. Otherwise, return a new <code>Nothing</code> of type <code>Maybe[U]</code>.</p> <pre><code>j1 = just[int](42)\nj2 = just[bool](True)\n\nassert j1.and_(j2).unwrap() == True\nassert (j1 &amp; j2).unwrap() == True\nassert (j1 &amp; nothing[bool]()).is_nothing()\nassert (nothing[int]() &amp; j2).is_nothing()\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.and_then","title":"<code>and_then(f)</code>","text":"<p>If the value is <code>Just</code>, apply a function that maps the inner value to a <code>Maybe[U]</code> value. Otherwise, return <code>Nothing</code> of type <code>Maybe[U]</code>.</p> <pre><code>j = just[int](114514)\n\nassert j.and_then(lambda x: some(x + 1805296)).unwrap() == 1919810\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.apply","title":"<code>apply(f)</code>","text":"<p>Implementation of Applicative.apply. Applies the callable wrapped within a <code>Maybe</code> to the inner value, if both are <code>Just</code>.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.bind","title":"<code>bind(f)</code>","text":"<p>Implementation of <code>Monad.bind</code>. Alias of <code>and_then</code>.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.duplicate","title":"<code>duplicate(m)</code>  <code>classmethod</code>","text":"<p>Create a shallow copy of a <code>Maybe</code> value.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.expect","title":"<code>expect(message)</code>","text":"<p>Unwrap the inner value, if any. Otherwise, raise a <code>ValueError</code> with a custom message.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is a <code>Nothing</code>.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.filter","title":"<code>filter(p)</code>","text":"<p>If the value is <code>Just</code> and satisfies the predicate, return the value. Otherwise, return <code>Nothing</code>.</p> <pre><code>j = just[int](42)\nassert j.filter(lambda x: x &gt; 0).unwrap() == 42\nassert j.filter(lambda x: x &lt; 0).is_nothing()\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.flatten","title":"<code>flatten()</code>","text":"<pre><code>flatten() -&gt; Maybe[T]\n</code></pre><pre><code>flatten() -&gt; Maybe[T]\n</code></pre> <p>Flatten a nested <code>Maybe</code> value for one level. Unlike <code>Option::flatten</code>, this method does not require the inner value to be a <code>Maybe</code>. If it's not a nested <code>Maybe</code>, this is a no-op.</p> <pre><code>j = just[Maybe[int]](just(42))\nassert j.flatten() == just(42)\n\nj2 = just[Maybe[Maybe[int]]](just(just(42)))\nassert j2.flatten() == just(just(42))\nassert j2.flatten().flatten() == just(42)\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.get_or_insert","title":"<code>get_or_insert(val)</code>","text":"<p>Get the inner value, if any. Otherwise, insert the new value and return the value.</p> <pre><code>j = just[int](42)\nassert j.get_or_insert(114514) == 42\n\nn = nothing[int]()\nassert n.get_or_insert(114514) == 114514\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.get_or_insert_with","title":"<code>get_or_insert_with(d)</code>","text":"<p>Get the inner value, if any. Otherwise, call a function to get a new value and return the value.</p> <pre><code>j = just[int](42)\nassert j.get_or_insert_with(lambda: 114514) == 42\n\nn = nothing[int]()\nassert n.get_or_insert_with(lambda: 114514) == 114514\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.insert","title":"<code>insert(val)</code>","text":"<p>Insert a value and returns it.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.is_just","title":"<code>is_just()</code>","text":"<p>Check if the value is a <code>Just</code>.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.is_just_and","title":"<code>is_just_and(p)</code>","text":"<p>Check if the value is a <code>Just</code> and satisfies the predicate.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.is_nothing","title":"<code>is_nothing()</code>","text":"<p>Check if the value is a <code>Nothing</code>.</p> <p>Note</p> <p>A <code>Just(Nothing)</code> value of type <code>Maybe[Maybe[T]]</code> or a <code>Just(None)</code> value of type <code>Maybe[Optional[T]]</code> are not <code>Nothing</code>s.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.just","title":"<code>just(val)</code>  <code>classmethod</code>","text":"<p>Construct a <code>Just</code> value.</p> <p>Warning</p> <p>Prefer using <code>just</code> instead, unless in performance-critical code.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.map","title":"<code>map(f)</code>","text":"<p>Apply a function that maps the inner value to a new value, if any. Otherwise, return <code>Nothing</code>.</p> <p>See <code>Option::map</code>.</p> <pre><code>j = just[int](42)\nassert j.map(lambda x: x + 1) == just(43)\n\nn = nothing[int]()\nassert n.map(lambda x: x + 1) == nothing()\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.map_or","title":"<code>map_or(default, f)</code>","text":"<p>Map the inner value using a function, or use the default value if absent.</p> <p>Tip</p> <p>If the default value is an expensive expression, use <code>map_or_else</code> instead.</p> <p>```python j = justint n = nothingint</p> <p>assert j.map_or(0, lambda x: x + 1) == 43 assert n.map_or(0, lambda x: x + 1) == 0 ```z</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.map_or_else","title":"<code>map_or_else(d, f)</code>","text":"<p>Map the inner value using a function, or use a lazy default value if absent.</p> <pre><code>j = just[int](42)\nn = nothing[int]()\n\nassert j.map_or_else(lambda: 0, lambda x: x + 1) == 43\nassert n.map_or_else(lambda: 0, lambda x: x + 1) == 0\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.nothing","title":"<code>nothing()</code>  <code>classmethod</code>","text":"<p>Construct a <code>Nothing</code> value.</p> <p>Warning</p> <p>Prefer using <code>Nothing</code> instead, unless in performance-critical code.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.or_","title":"<code>or_(other)</code>","text":"<p>If the value is <code>Just</code>, return a shallow copy of itself. Otherwise, return the other <code>Maybe</code>'s shallow copy.</p> <p>Notice that the right-hand side should be a <code>Maybe</code> object with the same inner type, although this is not enforced at runtime. And also this method does not short-circuit.</p> <pre><code>j1 = just[int](42)\nj2 = just[int](114514)\n\nassert (j1 | j2).unwrap() == 42\nassert (nothing[int]() | j2).unwrap() == 114514\nassert (j1 | nothing[int]()).unwrap() == 42\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.or_else","title":"<code>or_else(f)</code>","text":"<p>Return a shallow copy of the <code>Maybe</code> if it contains a value, otherwise call a function to get a result.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.pure","title":"<code>pure(x)</code>  <code>classmethod</code>","text":"<p>Implementation of Applicative.pure, which is equivalent to Maybe.just.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.replace","title":"<code>replace(val)</code>","text":"<p>Replace the inner value with a new value, returning the old value. After replacement, <code>self</code> will always have a value.</p> <pre><code>j = just[int](42)\nold = j.replace(114514)\nassert j == just(114514)\nassert old == just(42)\n\nn = nothing[int]()\nold = n.replace(1919810)\nassert n == just(1919810)\nassert old == nothing()\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.some","title":"<code>some(val)</code>  <code>classmethod</code>","text":"<p>Convert an <code>Optional[T]</code> value to a <code>Maybe</code> value.</p> <p>Warning</p> <p>Prefer using <code>some</code> function instead, unless in performance-critical code.</p> <pre><code>some = Maybe.some(42)\nassert some.is_just()\n\nnone = Maybe.some(None)\nassert none.is_nothing()\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.take","title":"<code>take()</code>","text":"<p>Take the inner value out and leave no value in place.</p> <pre><code>j = just[int](42)\nout = j.take()\nassert j.is_nothing()\nassert out == just(42)\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.take_if","title":"<code>take_if(p)</code>","text":"<p>Take the inner value out if it satisfies the predicate, and leave no value in place. Otherwise, take out nothing.</p> <pre><code>j = just[int](42)\nout = j.take_if(lambda x: x &gt; 0)\nassert j.is_nothing()\nassert out == just(42)\n\nj = just[int](42)\nout = j.take_if(lambda x: x &lt; 0)\nassert j.is_just()\nassert out == nothing()\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.tap","title":"<code>tap(f)</code>","text":"<p>Call a function with the inner value, if any, and return the <code>Maybe</code> itself. Unlike <code>Option::inspect</code>, this method does not require the function to return <code>None</code>.</p> <pre><code>j = just[int](42)\nj.tap(print)  # prints 42\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.unwrap","title":"<code>unwrap()</code>","text":"<p>Unwrap the inner value, if any. Otherwise, raise a <code>ValueError</code>.</p> <pre><code>j = just[int](42)\nn = nothing[int]()\n\nassert j.unwrap() == 42\n\ntry: n.unwrap()\nexcept ValueError: pass\nelse: assert False\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is a <code>Nothing</code>.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.unwrap_or","title":"<code>unwrap_or(default)</code>","text":"<p>Unwrap the inner value, or return a default value if absent.</p> <pre><code>j = just[int](42)\nn = nothing[int]()\nassert j.unwrap_or(0) == 42\nassert n.unwrap_or(0) == 0\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.unwrap_or_else","title":"<code>unwrap_or_else(f)</code>","text":"<p>Unwrap the inner value, or return a value computed by a function if absent.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.unwrap_unchecked","title":"<code>unwrap_unchecked()</code>","text":"<p>Return the inner value without checking if it is a <code>Just</code> or <code>Nothing</code>.</p>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.xor","title":"<code>xor(other)</code>","text":"<p>If only one side has a value, return that side. Otherwise, return a <code>Nothing</code>.</p> <pre><code>j1 = just[int](42)\nj2 = just[int](114514)\nassert j1.xor(j2).is_nothing()\n</code></pre>"},{"location":"container/maybe/#apfel.container.maybe.Maybe.zip","title":"<code>zip(*others)</code>","text":"<pre><code>zip(*others: *tuple[]) -&gt; Maybe[tuple[T,]]\n</code></pre><pre><code>zip(*others: *tuple[Maybe[T1],]) -&gt; Maybe[tuple[T, T1]]\n</code></pre><pre><code>zip(*others: *tuple[Maybe[T1], Maybe[T2]]) -&gt; Maybe[tuple[T, T1, T2]]\n</code></pre><pre><code>zip(*others: *tuple[Maybe[T1], Maybe[T2], Maybe[T3]]) -&gt; Maybe[tuple[T, T1, T2, T3]]\n</code></pre><pre><code>zip(*others: *tuple[Maybe[T1], Maybe[T2], Maybe[T3], Maybe[T4]]) -&gt; Maybe[tuple[T, T1, T2, T3, T4]]\n</code></pre> <p>Combine multiple <code>Maybe</code> values into a single <code>Maybe</code> value containing a tuple of them. If all values are <code>Just</code>, return a <code>Just</code> value with a tuple of inner values. Otherwise, return a <code>Nothing</code>. Calling this method with no arguments is equivalent to calling <code>map</code> with a tuple constructor.</p> <p>Typing</p> <p>The type checker only supports zipping up to 5-tuple.</p> <pre><code>j1 = just[int](42)\nj2 = just[int](114514)\nassert j1.zip(j2).unwrap() == (42, 114514)\n\nn = nothing[int]()\nassert j1.zip(n).is_nothing()\n</code></pre>"},{"location":"container/once/","title":"Once","text":"<p>Primitives for containers that can be written only once. Inspired by <code>OnceCell</code> and <code>LazyCell</code>.</p>"},{"location":"container/once/#apfel.container.once--implementation","title":"Implementation","text":"<p><code>Once</code> takes reference from <code>OnceCell</code> and the current status is as follows:</p> Reference <code>OnceCell</code> Counterpart <code>get</code> <code>get_mut</code> <code>get_mut_or_init</code> <code>get_mut_or_try_init</code> <code>get_or_init</code> <code>get_or_try_init</code> <code>into_inner</code> <code>new</code> <code>set</code> <code>take</code> <code>try_insert</code>"},{"location":"container/once/#apfel.container.once.Once","title":"<code>Once</code>","text":"<p>A container that can be written only once. See <code>OnceCell</code> for more information.</p>"},{"location":"container/once/#apfel.container.once.Once.__bool__","title":"<code>__bool__()</code>","text":"<p>Check if the <code>Once</code> container has been set.</p> <p>Returns:</p> Name Type Description <code>is_set</code> <code>bool</code> <p><code>True</code> if the <code>Once</code> container has been set, <code>False</code> otherwise.</p>"},{"location":"container/once/#apfel.container.once.Once.__init__","title":"<code>__init__()</code>","text":"<p>Create an unpopulated <code>Once</code> container.</p> <p>Returns:</p> Name Type Description <code>container</code> <code>Once</code> <p>An unpopulated <code>Once</code> container.</p>"},{"location":"container/once/#apfel.container.once.Once.get_or_init","title":"<code>get_or_init(f)</code>","text":"<p>Get the inner value of the <code>Once</code> container, or initialize it with the given function if no value has been set.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[], T]</code> <p>The function to initialize the <code>Once</code> container with if no value has been set.</p> required <p>Returns:</p> Name Type Description <code>value</code> <code>T</code> <p>The inner value (maybe newly set) of the <code>Once</code> container.</p>"},{"location":"container/once/#apfel.container.once.Once.set","title":"<code>set(value)</code>","text":"<p>Set the inner value of the <code>Once</code> container. If a value has already been set, this method currently does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to set the <code>Once</code> container to.</p> required Experimental <p>This method will return a <code>Result</code> type in the future.</p>"},{"location":"container/once/#apfel.container.once.Once.unwrap","title":"<code>unwrap()</code>","text":"<p>Get the inner value of the <code>Once</code> container. If no value has been set, this method raises a <code>ValueError</code>.</p> <p>Returns:</p> Name Type Description <code>value</code> <code>T</code> <p>The inner value of the <code>Once</code> container.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no value has been set.</p>"},{"location":"container/once/#apfel.container.once.Lazy","title":"<code>Lazy</code>","text":"<p>A container that can be lazily initialized only once. The stored function will be actually called only on the first retrieval, and the result will be cached for consequent calls. See <code>LazyCell</code> for more information.</p> Example <pre><code>from apfel.container.once import Lazy\n\n@Lazy\ndef f():\n    print(\"called\")\n    return object()\n\nobj = f.value()\n# print \"called\"\n# here, the function `f` will be called and the result will be cached.\n\nf.value() is obj # the function `f` will not be called again.\n</code></pre>"},{"location":"container/once/#apfel.container.once.Lazy.__call__","title":"<code>__call__()</code>","text":"<p>An alias for <code>Lazy.value</code>. Notice that this operator overloading might be slower than calling <code>value</code> directly.</p> Example <pre><code>@Lazy\ndef f():\n    return object()\n\nobj = f()\nassert f() is obj\n</code></pre>"},{"location":"container/once/#apfel.container.once.Lazy.__init__","title":"<code>__init__(f)</code>","text":"<p>Create a lazily initialized <code>Lazy</code> container.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[], T]</code> <p>The function to be lazily initialized.</p> required"},{"location":"container/once/#apfel.container.once.Lazy.unwrap","title":"<code>unwrap()</code>","text":"<p>Get the inner value of the <code>Lazy</code> container. If no value has been set, this method raises a <code>ValueError</code>.</p> <p>Returns:</p> Name Type Description <code>value</code> <code>T</code> <p>The lazily initialized value of the <code>Lazy</code> container.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no value has been set.</p>"},{"location":"container/once/#apfel.container.once.Lazy.value","title":"<code>value()</code>","text":"<p>Get the inner value of the <code>Lazy</code> container. If no value has been set, this method initializes the value with the stored function.</p> <p>Returns:</p> Name Type Description <code>value</code> <code>T</code> <p>The lazily initialized value of the <code>Lazy</code> container.</p>"},{"location":"core/","title":"Core","text":"<p>Core utilities functions that are directly exposed by the <code>apfel</code> package.</p> <p>These functions are injected to the <code>builtins</code> namespace and can be used directly   as soon as the <code>apfel</code> package is imported. If you are using Pyright, you can follow the builtins extension documentation to enable autocompletion for these functions.</p>"},{"location":"core/#apfel.identity","title":"<code>identity(x)</code>","text":"<p>Returns the sole argument passed to it doing nothing.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>T</code> <p>Any object.</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>T</code> <p>The same object passed to it.</p>"},{"location":"core/#apfel.imperative","title":"<code>imperative(*exprs)</code>","text":"<pre><code>imperative() -&gt; None\n</code></pre><pre><code>imperative(*exprs: *tuple[*Ts, R]) -&gt; R\n</code></pre> <p>Returns the last expression passed into the function. If no expression are passed, returns <code>None</code>, per Python's convention.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>*tuple[*Ts, R]</code> <p>Any number of expressions. </p> <code>()</code> <p>Returns:</p> Name Type Description <code>out</code> <code>R</code> <p>The last expression passed into the function.</p>"},{"location":"core/#apfel.todo","title":"<code>todo(message=None)</code>","text":"<p>Marks an unimplemented location that might be implemented in the future. See <code>todo!</code> for usage.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | None</code> <p>The extra message to be displayed.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always.</p>"},{"location":"core/#apfel.unimplemented","title":"<code>unimplemented(message=None)</code>","text":"<p>Marks an unimplemented location that might not be implemented in the future. See <code>unimplemented!</code> for usage.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | None</code> <p>The extra message to be displayed.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always.</p>"},{"location":"core/dispatch/","title":"Dispatch","text":"<p>Dynamic dispatch facilities for Python.</p> <p>This addresses the lack of runtime-available, inheritance-free interfaces in Python. It partially resembles the <code>extension</code> and <code>trait</code>.</p>"},{"location":"core/dispatch/#apfel.core.dispatch--rationale","title":"Rationale","text":"<p>Why not <code>functools.singledispatch</code>?</p> <ul> <li>Runtime behavior based on type hints can be confusing.</li> <li>It's method variant <code>functools.singledispatchmethod</code> dispatches methods based on the first non-<code>self</code> argument, which is very different from the single dispatch found in other object-oriented programming languages.</li> </ul> <p>Why not <code>abc.ABC</code>?</p> <ul> <li>It does not enable <code>virtual</code>-like or <code>dyn</code>-like dispatch. An <code>abstractmethod</code> in an abstract class will not forward the call to the concrete implementation based on the real type. i.e., there is no facilities for implementation selection based on concrete types.</li> <li>Although <code>ABCMeta.register</code> can be used to register non-child classes, it cannot inject implementations to the registered classes.  Some classes do not allow monkey-patching and the implementations must be stored elsewhere, registering them to the ABC is logical error, as the implementations are not part of the concrete class.</li> </ul> <p>Using <code>ABCDispatch</code> defined in this module,</p> <ul> <li>All ABC features work out of the box. Supports static type checking (inheritance-based usages only), non-inheritance based runtime type checking, and <code>@abstractmethod</code>.</li> <li>Abstract methods defined in an <code>ABCDispatch</code> can dynamically forward the call to the concrete implementation based on the real type, and the implementations can be externally provided.   For example, an <code>ABCDispatch</code> can be used to extend built-in classes.</li> </ul>"},{"location":"core/dispatch/#apfel.core.dispatch--usage","title":"Usage","text":"<p>First, define a class that subclasses <code>ABCDispatch</code>. This class will be semantically similar to Rust traits. All interface functions defined in this method shall be decorated with <code>@abc.abstractmethod</code>. Class methods and static methods can also be defined with the same decorator.</p> Warning <p>The <code>@abstractmethod</code> decorator must be placed after the <code>@classmethod</code> or <code>@staticmethod</code> decorator.</p> <pre><code>class Trait(ABCDispatch):\n    @abstractmethod\n    def method(self, f): ...\n\n    @classmethod\n    @abstractmethod\n    def class_method(cls, f): ...\n\n    @staticmethod\n    @abstractmethod\n    def static_method(f): ...\n</code></pre> <p>Then, we can implement the \"trait\" for a class by using the <code>@impl</code> decorator. The implementor class is passed as the first argument to the decorator. The implementation is written in the <code>class</code> syntax, with each trait method implemented as a method of the class. The class name doesn't matter, but it should subclass the trait class.</p> <pre><code>@impl(Class)\nclass _(Trait):\n    def method(self, f): \"\"\"Concrete implementation goes here\"\"\"\n\n    @classmethod\n    def class_method(cls, f): \"\"\"Concrete implementation goes here\"\"\"\n\n    @staticmethod\n    def static_method(f): \"\"\"Concrete implementation goes here\"\"\"\n</code></pre> <p>In this case, <code>Class.method</code> does not exist during runtime so you may not call it, and calling <code>.method</code> on an instance of <code>Class</code> will also fail. But you can call <code>Trait.method</code> on an instance of <code>Class</code> and it will dispatch to the concrete implementation defined in the <code>@impl</code> construct.</p> <pre><code>c = Class()\nTrait.method(c, f)  # Calls the implementation within the @impl\n</code></pre> <p>If you have control to the source code, you can add <code>Trait</code> to the base classes of <code>Class</code>, so <code>Class.method(instance)</code> and <code>instance.method()</code> will work as expected, <code>Trait.method(instance, f)</code> shall also work.</p> <p>Class methods and static methods shall be called with the generic syntax, as the concrete class is not inferrable from the function's call arguments.</p> <pre><code>Trait.class_method[Class](f)\nTrait.static_method[Class](f)\n</code></pre> <p>It's also possible to define a dispatchable function using the <code>@dispatch</code> decorator. Then an method <code>impl_for</code> will be on the function, which can be used to register implementations.</p> <pre><code>@dispatch\ndef f(x): ...\n\n@f.impl_for(int)\ndef _(x: int):\n    \"\"\"Implementation for int goes here\"\"\"\n</code></pre> Example <p>You can check the <code>Functor</code>'s source code as an example of how to use this module.</p> <p>By default <code>ABCDispatch</code> and <code>@dispatch</code> defines a single dispatch. This means the runtime imlementation selection is based on the concrete type of first argument of the function, or of the receiver in the case of methods.</p>"},{"location":"core/dispatch/#apfel.core.dispatch.ABCDispatch","title":"<code>ABCDispatch</code>","text":"<p>An <code>ABC</code> that enables single dispatch for its abstract methods. This behaves similarly to <code>abc.ABC</code> but with the added feature of dynamic concrete implementation selection under single dispatch. Stick to built-in <code>abc.abstractmethod</code> to define abstract methods.</p> <p>See the usage section for more information.</p> Example <pre><code>from abc import abstractmethod\nfrom apfel.core.dispatch import ABCDispatch\n\nclass A(ABCDispatch):\n    @abstractmethod\n    def hi(self):\n        print(self)\n\n    @classmethod\n    @abstractmethod\n    def hey(cls):\n        print(cls)\n\na: A = some_instance()\nA.hi(a)\n</code></pre>"},{"location":"core/dispatch/#apfel.core.dispatch.dispatch","title":"<code>dispatch(func)</code>","text":"<p>A decorator for creating a single-dispatchable function. It will add an <code>impl_for</code> method to the function, which can be used to register implementations. Calling the function will dispatch to the correct implementation based on the type of the first argument.</p> <p>This is similar to <code>functools.singledispatch</code>, but does not use type hints for dispatching, and static type unions are not supported.</p> Example <pre><code>@dispatch\ndef show(x):\n    ...\n\n@show.impl_for(int)\ndef _(x: int):\n    return f\"int: {x}\"\n\n@show.impl_for(str)\ndef _(x: str):\n    return f\"str: {x}\"\n\nshow(1)       # \"int: 1\"\nshow(\"hello\") # \"str: hello\"\n</code></pre>"},{"location":"core/dispatch/#apfel.core.dispatch.impl","title":"<code>impl(definition)</code>","text":"<p>Decorator for registering an implementation using the <code>class</code> syntax.</p> <p>See the usage section for more information.</p> Example <p>Here <code>Class</code> is a concrete class and <code>Trait</code> is an <code>ABCDispatch</code>. <pre><code>@impl(Class)\nclass _(Trait):\n    def method(self, f): \"\"\"Concrete implementation goes here\"\"\"\n\n    @classmethod\n    def class_method(cls, f): \"\"\"Concrete implementation goes here\"\"\"\n\n    @staticmethod\n    def static_method(f): \"\"\"Concrete implementation goes here\"\"\"\n</code></pre></p>"},{"location":"core/dispatch/#apfel.core.dispatch.add_impl","title":"<code>add_impl(definition, impl, *impl_for_args, **impl_for_kwargs)</code>","text":"<p>An imperative interface for adding implementations to a dispatchable class. For a declarative interface, use the <code>@impl</code> decorator.</p> <p>If the dispatchable class is an <code>ABCDispatch</code> which does single dispatch, the <code>impl_for_args</code> param should be the type of the implementor class.</p> <p>Parameters:</p> Name Type Description Default <code>definition</code> <code>type</code> <p>The dispatchable class.</p> required <code>impl</code> <code>Mapping[str, Callable]</code> <p>A mapping from method names to implementations.</p> required <code>*impl_for_args</code> <p>Arguments that the dispatch mechanism will use for selecting the implementation.</p> <code>()</code> <code>**impl_for_kwargs</code> <p>Keyword arguments that the dispatch mechanism will use for selecting the implementation.</p> <code>{}</code> Example <pre><code># The following imperative code ...\nadd_impl(Trait, {\"method\": lambda self, f: f}, Class)\n\n# ... is equivalent to the following declarative code:\n@impl(Class)\nclass _(Trait):\n    def method(self, f): return f\n</code></pre>"},{"location":"core/function-object/","title":"Function Object","text":"<p>Extend functions with operator overloads for function calling.</p> <p>Conceptually, function objects are objects that implement the function call operator.</p>"},{"location":"core/function-object/#apfel.core.function_object--rationale","title":"Rationale","text":"<p>Python codes contain extensive use of parentheses, which can be cumbersome in interactive environments. This module simply provides a way to reduce the pain of wrapping huge expressions in parentheses. You can use application operators provided by <code>FunctionObject</code> to apply the function on the following expression. Use the <code>fob</code> function to turn a function or a sequence of functions into <code>FunctionObject</code>s.</p>"},{"location":"core/function-object/#apfel.core.function_object--usage","title":"Usage","text":"TL;DR <p>Use and only use function objects in interactive environments.</p> <p>For example, <code>f(..)</code> is equivalent to <code>f | (...)</code> or <code>f @ (...)</code>. Writing <code>f(...)</code> as <code>f@(...)</code> seems redundant, but these <code>@</code> usages can be purged easily with simple search and replace. <code>FunctionObject</code>'s operators are carefully chosen, as they:</p> <ol> <li>are relatively rare in Python</li> <li>have different precedence and associativity</li> </ol> <p>This is especially useful when you wrap some debugging or logging code around a function call. For example, with the following usage with <code>icecream</code>, you can replace <code>ic @</code> with empty string to remove all debugging code, without worrying of breaking the <code>get_pic()</code> call:</p> <pre><code>from icecream import ic as _ic\n\nic = fob(_ic)\nresult = ic @ (\n    get_pic(iris)\n        .filter(...)\n        .sort_values(...)\n        .apply(...)\n        .head(10)\n)\n</code></pre> <p><code>|</code> and <code>@</code> have different operator precedence, the <code>|</code> has almost the lowest precedence of all Python operators, while the <code>@</code> has almost the highest precedence. This allows you combine expressions more flexibly without worrying about parentheses.</p> <p><code>&amp;</code> operator can be used to apply the function to its left-hand side, if the left-hand side does not overload the <code>&amp;</code> operator. This is similar to <code>&amp;</code>, <code>|&gt;</code> or roughly <code>%&gt;%</code>. With <code>&amp;</code> you can write your code naturally from left to right.</p> <pre><code>from icecream import ic as _ic\nic = fob(_ic)\n\nresult = (\n    get_pic(iris)\n        .filter(...)\n        # ...\n) &amp; ic\n</code></pre> <p><code>**</code> operator has the highest precedence of all, and it has a unique associtivity from right to left. It can be used in wrapping multiple calls together without parentheses, like <code>f(g(x))</code> can be written as <code>f ** g ** x</code>. It roughly simulates <code>$</code>.</p> <p><code>%</code> operator is used for calling multi-argument functions. Check its documentation for more details.</p> Tip <p>Function objects come with runtime costs. Although negligible most of the time, the cost could accumulate on critical paths.</p> <p><code>FunctionObject</code>s also have less static typing support. Do not use them in type-checked code.</p> Warning <p>Wrapping callables other than functions with <code>FunctionObject</code> may lose attributes  and methods of the original callable.</p> Warning <p>For performance considerations, <code>apfel</code> APIs are not wrapped in <code>FunctionObject</code>s.</p>"},{"location":"core/function-object/#apfel.core.function_object.FunctionObject","title":"<code>FunctionObject</code>","text":""},{"location":"core/function-object/#apfel.core.function_object.FunctionObject.__matmul__","title":"<code>__matmul__(rhs)</code>","text":"<pre><code>def @[T, R](self, rhs: T) -&gt; R\n</code></pre> <p>Function application operator <code>@</code> for <code>FunctionObject</code>s.</p> <p><code>f @ x</code> is equivalent to <code>f(x)</code>. This operator behaves the same as <code>|</code>, but with a different precedence.</p> Example <pre><code>@fob\ndef f(x):\n    return x * 2\n\nf @ 1 + 2\n# 4\n</code></pre>"},{"location":"core/function-object/#apfel.core.function_object.FunctionObject.__mod__","title":"<code>__mod__(rhs)</code>","text":"<pre><code>def %[R](self, rhs) -&gt; R\n</code></pre> <p>Function application operator <code>%</code> for <code>FunctionObject</code>s of multi-argument functions.</p> <ul> <li>If the right hand side is a Sequence, spreads the sequence as positional arguments. For example, <code>x % (a, b, c)</code> is equivalent to <code>x(a, b, c)</code>.</li> <li>If the right hand side is a Mapping, spreads the mapping as keyword arguments. For example, <code>x % { \"a\": 1, \"b\": 2, \"c\": 3 }</code> is equivalent to <code>x(a=1, b=2, c=3)</code>.</li> <li>Specifically, you can use <code>...</code> as the map key to pass keyword arguments with keyword arguments at the same time, <code>x % { ...: (1, 2), \"c\": 3 }</code> is equivalent to <code>x(1, 2, c=3)</code>.</li> <li>Otherwise, it calls on the right-hand side. This catches the case where you forget the trailing comma in the right-hand side tuple.</li> </ul> Example <pre><code>@fob\ndef f(a, b, c):\n    return a + b + c\n\nf % (1, 2, 3)                  # 6\nf % { \"a\": 1, \"b\": 2, \"c\": 3 } # 6\nf % { ...: (1, 2), \"c\": 3 }    # 6\n</code></pre> Warning <p>This operator does not support the case where <code>...</code> (the <code>Ellipsis</code>, not <code>\"...\"</code>) is used as a keyword argument. However, this case is relatively rare, as <code>...</code> cannot be declared as argument name.</p>"},{"location":"core/function-object/#apfel.core.function_object.FunctionObject.__or__","title":"<code>__or__(rhs)</code>","text":"<pre><code>def |[T, R](self, rhs: T) -&gt; R\n</code></pre> <p>Function application operator <code>|</code> for <code>FunctionObject</code>s.</p> <p><code>f | x</code> is equivalent to <code>f(x)</code>. This operator behaves the same as <code>@</code>, but with a different precedence.</p> Example <pre><code>@fob\ndef f(x):\n    return x * 2\n\nf | 1 + 2\n# 6\n</code></pre>"},{"location":"core/function-object/#apfel.core.function_object.FunctionObject.__pow__","title":"<code>__pow__(rhs)</code>","text":"<pre><code>def **[T, R](self, rhs: T) -&gt; R\n</code></pre> <p>Function application operator <code>**</code> for <code>FunctionObject</code>s.</p> <p><code>f ** g ** x</code> is equivalent to <code>f(g(x))</code>. This operator has the highest precedence of all overloadable operators, and it binds from right to left. It intends to simulate <code>$</code> operator, except the precedence.</p> Example <pre><code>@fob\ndef f(x):\n    return x + 1\n\n@fob\ndef g(x):\n    return x * 2\n\nf ** g ** 1\n# 3\n</code></pre>"},{"location":"core/function-object/#apfel.core.function_object.FunctionObject.__rand__","title":"<code>__rand__(lhs)</code>","text":"<p><pre><code>def &amp;[T, R](self, lhs: T) -&gt; R\n</code></pre> Reverse function application operator <code>&amp;</code> for <code>FunctionObject</code>s. This operator overloading targets the right-hand side.</p> <p><code>x &amp; f</code> is equivalent to <code>f(x)</code>, if <code>&amp;</code> operator (left, <code>__and__</code>) is not overloaded by <code>x</code>'s type.</p> Warning <p><code>np.array</code> and array-like types are common overloaders of <code>&amp;</code>, therefore this operator cannot be used with them.</p> Example <pre><code>@fob\ndef f(x):\n    return x + 1\n\n1 + 2 &amp; f\n# 6\n</code></pre>"},{"location":"core/function-object/#apfel.core.function_object.fob","title":"<code>fob(f, *fs)</code>","text":"<pre><code>def fob[F: Callable](f: F) -&gt; F\ndef fob[*Fs](*fs: *Fs) -&gt; tuple[*Fs]\n</code></pre> <p>Turn callables into <code>FunctionObject</code> yet keeps their original type hints.</p> Example <pre><code>@fob\ndef f(a: int) -&gt; int:\n    return f + 1\n\nf | 1\n# 2\n\nprint, display, str = fob(print, display, str)\n</code></pre> Note <p>As a callable, <code>FunctionObject</code> has less static typing support. <code>@fob</code> erases type hints of <code>FunctionObject</code> while keeping the runtime type. If you want to retain the type hints, directly use <code>FunctionObject</code>'s constructor, or use <code>reveal_fob</code> on an object with runtime type <code>FunctionObject</code>.</p>"},{"location":"core/function-object/#apfel.core.function_object.reveal_fob","title":"<code>reveal_fob(f)</code>","text":"<pre><code>def reveal_fob(func: Any) -&gt; FunctionObject raise TypeError\n</code></pre> <p>Cast a <code>FunctionObject</code> to <code>FunctionObject</code> type.</p> Exception <p>This function performs runtime check and raises <code>TypeError</code> if the input is not a <code>FunctionObject</code>.</p>"},{"location":"core/monad/","title":"Monad","text":"Meme <p>A monad is a monoid in the category of endofunctors.</p> <p>Monadic interfaces that enable structured ways to compose and manipulate computations on a single effectful construction.</p> <p>The module defines three abstract classes: <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code>.</p>"},{"location":"core/monad/#apfel.core.monad--rationale","title":"Rationale","text":"<p>Monadic abstractions like <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> are popularized by Haskell. Although Python has weak support for functional programming, we include these abstractions to provide a uniform interface for such calculations.</p> <p>Under the hood, these abstractions use dynamic single dispatch provided in <code>apfel.core.dispatch</code>, which allows us to define monadic helper functions for standard built-in types. This module provides default implementations for <code>list</code>, <code>tuple</code>, <code>set</code>, and <code>function</code> as <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code>, <code>dict</code> as <code>Functor</code>.</p> <p>Note that we losen the constraints of such abstractions, as writing pure functional code is not a goal of this library.</p>"},{"location":"core/monad/#apfel.core.monad--usage","title":"Usage","text":"<p>Here's a high-level comparison of the three. Assume <code>Value</code> is a <code>Monad</code>. A <code>Monad</code> is always a <code>Functor</code> and an <code>Applicative</code>.</p> <pre><code>value = Value(42)\n\nassert value.map  (      lambda x: x + 1 ) == Value(43)\nassert value.apply(Value(lambda x: x + 1)) == Value(43)\nassert value.bind (lambda x: Value(x + 1)) == Value(43)\n</code></pre> <p>If you are familiar with Rust, <code>Option</code> is a <code>Monad</code>, <code>Option.map</code> is its <code>Functor.map</code>, <code>Option.and_then</code> is its <code>Monad.bind</code>.</p>"},{"location":"core/monad/#apfel.core.monad--case-list","title":"Case: <code>list</code>","text":"<pre><code>assert Functor.map([1, 2, 3], lambda x: x + 1) == [2, 3, 4]\nassert Applicative.apply([1, 2, 3], [lambda x: x + 1, lambda x: x + 2]) == [2, 3, 4, 3, 4, 5]\nassert Monad.bind([1, 2, 3], lambda x: [x, x + 1]) == [1, 2, 2, 3, 3, 4]\n</code></pre>"},{"location":"core/monad/#apfel.core.monad--case-function","title":"Case: <code>function</code>","text":"<p><code>Functor.map</code> of a function is exactly a composition of functions.</p> <pre><code>assert Functor.map(lambda x: x * 2, lambda x: x + 1)(2) == 5\n</code></pre>"},{"location":"core/monad/#apfel.core.monad.Functor","title":"<code>Functor</code>","text":"<pre><code>class Functor[T](ABC):\n    map\n</code></pre> <p>A functor is a type that can apply a function to its inner value(s) without changing its structure.</p> <p>To implement a <code>Functor</code>, you need to implement at least the <code>map</code> method.</p> <p>See Functor for more information.</p>"},{"location":"core/monad/#apfel.core.monad.Functor.map","title":"<code>map(f)</code>  <code>abstractmethod</code>","text":"<pre><code>def map[F, R](self, f: F) -&gt; Self[R]\n    where F: Callable[[T], R]\n</code></pre> <p>Apply a function to the inner value(s) of the functor, returning a new  instance of the functor. This corresponds to the <code>fmap</code> in Haskell.</p> <p>Built-in <code>map</code> function returns an iterator, not a new instance of the functor.</p> Example <pre><code>add = lambda x: x + 1\nFunctor.map([1, 2, 3], add) # [2, 3, 4]\nmap([1, 2, 3], add)         # &lt;map object at ...&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[T], R]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Functor[R]</code> <p>A new instance of the functor with transformed inner value(s).</p>"},{"location":"core/monad/#apfel.core.monad.Applicative","title":"<code>Applicative</code>","text":"<pre><code>class Applicative[T](Functor):\n    pure\n    apply\n</code></pre> <p>An applicative functor is a functor extended with the ability to apply an effectful function to its inner value(s).</p> <p>To implement an <code>Applicative</code>, you need to implement at least the <code>pure</code> and <code>apply</code> methods.</p> <p>See Applicative for more information.</p>"},{"location":"core/monad/#apfel.core.monad.Applicative.apply","title":"<code>apply(f)</code>  <code>abstractmethod</code>","text":"<pre><code>def apply[F, R](self, f: F) -&gt; Self[R]\n    where F: Self[Callable[[T], R]]\n</code></pre> <p>Applies a function wrapped inside the applicative structure to the inner value(s) of this applicative.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Applicative[Callable[[T], R]]</code> <p>The applicative that contains the function to apply.</p> required <p>Returns:</p> Type Description <code>Applicative[R]</code> <p>A new instance of the applicative with the transformed inner value(s).</p>"},{"location":"core/monad/#apfel.core.monad.Applicative.pure","title":"<code>pure(x)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>def pure(cls, x: T) -&gt; Self[T]\n</code></pre> <p>Wrap a value into the applicative structure.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>T</code> <p>The value to wrap.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the applicative with the value wrapped.</p>"},{"location":"core/monad/#apfel.core.monad.Monad","title":"<code>Monad</code>","text":"<pre><code>class Monad[T](Applicative):\n    bind\n    (Applicative.pure)\n</code></pre> <p>A monad is an applicative functor extended with the ability to reuse results of previous computations and chain effectful computations together.</p> <p>To implement a <code>Monad</code>, you need to implement at least the <code>bind</code> method, and the <code>pure</code> method from <code>Applicative</code>.</p> <p>See Monad for more information.</p> Notes <p><code>return</code> is a reserved keyword in Python, and Haskell <code>return</code> is a historical mistake that is now pointing to <code>pure</code>.</p>"},{"location":"core/monad/#apfel.core.monad.Monad.bind","title":"<code>bind(f)</code>  <code>abstractmethod</code>","text":"<pre><code>def bind[F, R](self, f: F) -&gt; Self[R]\n    where F: Callable[[T], Self[R]]\n</code></pre> <p>Chain a new monadic computation to the current one.</p> <p>The argument <code>f</code> maps a pure value of the monad's inner type to the monadic value. <code>bind</code> chains this computation to the one it represents. If its computation fails, the following computations will not be executed.</p> <p>The function <code>f</code> is called a Kleisli arrow. This <code>bind</code> operation has other names in different programming languages. For example, in <code>Option</code> monad, it is called <code>and_then</code>.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[T], Monad[R]]</code> <p>The function that returns a new monadic computation.</p> required <p>Returns:</p> Type Description <code>Monad[R]</code> <p>A new instance of the monad with the result of the chained computation.</p>"},{"location":"core/monad/#apfel.core.monad.fmap","title":"<code>fmap = Functor.map</code>  <code>module-attribute</code>","text":"<p>An alias for <code>Functor.map</code>.</p>"},{"location":"impt/","title":"Import","text":"<p><code>apfel.impt</code> provides import facilities for compile-time meta-programming.</p>"},{"location":"impt/#low-level","title":"Low-level","text":"<ul> <li><code>Transform</code>: Transform source files during import.</li> </ul>"},{"location":"impt/transform/","title":"Transform","text":"<p>This module provides a low-level hook mechanism to transform the source code of a package or module during its import. It must be imported before any other packages and modules that you want to hook.</p> <p>Effectful</p> <p>This package has an effectful behavior: modifying the <code>sys.meta_path</code> finder list, which will affect the import process, and is sensitive to the order of imports.</p> <p>Normally you would use adapters defined in the <code>impt</code> package, instead of directly using the low level <code>register_transform_hook</code> function.</p>"},{"location":"impt/transform/#apfel.impt.transform.TransformPathFinder","title":"<code>TransformPathFinder</code>","text":"<p>A subclass of <code>importlib.machinery.PathFinder</code> that injects <code>TransformSourceFileLoader</code> to the import process.</p>"},{"location":"impt/transform/#apfel.impt.transform.TransformSourceFileLoader","title":"<code>TransformSourceFileLoader</code>","text":"<p>A subclass of <code>importlib.machinery.SourceFileLoader</code> that applies all registered hooks to the source code of a module or package during import.</p> <p>Implementation</p> <p>This loader will directly read the source code from the <code>.py</code> file, completely ignoring the <code>.pyc</code> file. The transformed source code will not have a bytecode cache (<code>.pyc</code>) generated. If your file system has high latency, this may slow down the import process.</p>"},{"location":"impt/transform/#apfel.impt.transform.register_transform_hook","title":"<code>register_transform_hook(name, hook)</code>","text":"<p>Register a hook function to replace the source code of a module or package.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the module or package to hook.</p> required <code>hook</code> <code>Callable[[str], str]</code> <p>The hook function that takes the original source code as input and returns the transformed source code.</p> required"}]}